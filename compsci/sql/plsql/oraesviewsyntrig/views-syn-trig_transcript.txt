
Code School
Oracle Developer Essentials: Views, Synonyms and Triggers
by David Berry

This course covers the essentials of creating and using views, synonyms, sequences, and triggers in your Oracle database.

Resume CourseBookmarkAdd to ChannelLive mentoring
Table of contents
Description
Transcript
Exercise files
Discussion
Learning Check
Recommended
Introduction

Course Overview

Hello. My name is David Berry. Welcome to Pluralsight, and this course on Views, Synonyms and Triggers in Oracle. This course is the third course in a three course sequence covering Oracle object essentials aimed at developers who work with Oracle. In the first course I covered tables and indexes, as these are some of the most fundamental data structures in Oracle for storing your data and making sure that you can retrieve that data quickly. In the second course I talked about data types in Oracle. When you build your tables, choosing the correct data type that fits the type of data you intend to store is critical in order to make your database easy to work with, and also get the best possible performance out of Oracle. In this third course we're going to discuss some of the other object types that are available in Oracle that you will not just come into contact with when using Oracle, but you will also want to make use of yourself when faced with certain scenarios. Now if you didn't take one of both of the first two courses, don't worry. While the courses are a logical sequence, they can also be taken independently. If you have a basic knowledge of SQL and how to create tables in Oracle, you'll be fine jumping right into this course. If you do, however, find yourself wanting to fill in some gaps in your knowledge about tables or indexes or data types, you can always go back and watch the relevant sections of the first two courses as needed. In this course we're going to start off by talking about views. What views do is encapsulate a SQL query that will provide a logical representation of the data in your tables. So in this way you can form a sort of virtual table on top of your physical tables. Views can be useful when you need to encapsulate a complex SQL statement into a single object, or for security purposes when you want to limit the number of rows or columns another user can see. There are a number of other scenarios where you also can make use of views, so you'll find yourself using views quite often. The second type of object we are going to discuss are synonyms. Synonyms allow you to define an alternate name for objects in your database. So these are really useful when you have an object that doesn't have a meaningful name. You can simply give it an alias via a synonym. Third we're going to talk about sequences in Oracle. Sequences allow you to generate unique integers, and they are thread safe. So no matter how many processes you have requesting unique values from the sequence at a time, Oracle has already done all of the hard work around writing thread safe code to make sure that these values will be unique. Finally, we're going to wrap up by talking about triggers, which are a way that you can specify an action be performed when an insert, update or delete statement is run against one of your tables. A good example of where you might want to use a trigger is when you want to archive the old version of a row from a table whenever that row is updated or deleted. What you can do is set up a trigger to do this such that the old version of the row gets copied over into an archive table. So we'll talk about how to create triggers and some of the common use cases that you will encounter.

Course Resources

In case you have not take the first two courses in the sequence, I want to take a quick moment to make you aware of some useful resources to aid you as you learn about and work with Oracle. The first is a link to the home page of all of the documentation for Oracle 12c. Oracle provides very extensive documentation with numerous examples. So this is a link that you'll want to bookmark in your browser. If you ever had a question on what syntax you need to use or how something works, this is the definitive resource to turn to. The second is a link to a number of virtual machines that Oracle provides that already have Oracle installed on them. Oftentimes it's very convenient to have your own sandbox where you can try something out in Oracle and see how it works. And this is true no matter where you're at with your learnings about Oracle. All you need to do to access these is to sign up for the Oracle Technology Network, which is free. Download the appropriate software and VMs, and you'll have your own Oracle sandbox that you can experiment with. The last resource I want to point you to is my blog, which is at the address on your screen. I've taken most of the code snippets from the course and put them up there on the blog, so if you want to download one of these and try it out or modify it for your own purposes, then you can just head to this address and download what you need. Also I have a number of other useful Oracle snippets from my other Pluralsight courses that I've posted here as well, so you can also check those out. I know you're eager to get started, so let's move right into talking about views in Oracle, and how we can make use of them.

Views

Overview

Hello. My name is David Berry. Welcome to this module on views in Oracle. In this module, we're going to talk about views. We'll start off by defining what a view is, and then we'll talk about situations when you might want to use a view. We'll then discuss how to create a view and what some of your options are. Next we'll talk about views and DML statements, because this is always a question that people have if they can execute insert, update, and delete statements against their views. Finally we'll wrap up with a discussion about how you might want to make use of views in your database, in your applications. Let's get started.

What Is a View?

A view is an object that acts as a virtual table. They give you a logical view of data from one or more other tables in your database. What you do is define a select statement that queries data from one or more tables, and this select statement defines the view. No data is stored in the view, just this defining sequel query. In this query you can join multiple tables together. You can filter rows via a where clause, or you can summarize data using aggregate function. When you use a view and a sequel statement, Oracle will substitute this query that defines the view into the sequel statement, and then parse and process your sequel statement as a whole. What a view really provides is convenience. Instead of writing certain sequel statements over and over again every time, you can encapsulate the statement into a view, and then just use the view in your other sequel statements. Why would we want to use a view in our database? There are a number of reasons. As we just mentioned, views can provide a lot of convenience. We might have several tables that we join together frequently in queries. We can create a view of this joined condition and just query the view so we don't have to type out all of the joined conditions each time. In this way we simply the sequel statement we are writing, because our joined is now encapsulated in the view. Another use of view is to assign a different name to a table or columns within a table. Maybe we have some names that aren't very expressive of the data they contain or don't adhere to the naming conventions we have. We can use a view as a wrap around the table, and then just interact with the view which has the names that are more meaningful to us. Finally we also can use views for security purposes. We may not want to give another user in our database direct access to one of our tables, because then they can see all of the data in the table. Using a view, we can include only the columns that we want them to see, or even restrict the rows that they can see in the view by using a where clause. Then what we do is grant the other user permission to the view and not the base table itself.

Creating Views

To create a view, you will need to have the create view privilege assigned to the user who is creating the view. Then you can say create view, or create and replace view as I am showing here. Using the create or replace syntax, Oracle will overwrite an existing definition of view with the definition it used specified here if the view already exists. Saving you the need to check if the view exists and potentially dropping the existing view. This is followed by the name of the view and the keyword, "as." The naming rules for views are the same as they are for tables which we covered back in module two of this course. The important rules to remember is that this name needs to be 30 characters or less in length, and if you stick to alpha numeric characters and the underscore character, you won't need to quote the name. Then you simply include the sequel query that will define the view. In this case, my query joins together three tables and uses a where clause to get the list of courses required for a computer science degree. It'll be the rows returned by this query that are encapsulated in the view. What you do need to be concerned about in your query is that every column returned by your sequel statement needs to have a unique name. As it will be this name that is used for the column name in the view. To give a column a different name, you would need to use the as keyword followed by name that the column will have in the view. You can do this in situations where you want to include two columns from different tables that have the same name, when you have an aggregate column like some or count that needs to be part of the view and you need to assign it a name, or as I'm doing here, when you just want to have a different name for that particular column in your view. Let's do a quick demonstration of some views so you can see them in action.

Demo: Creating and Using Views

I have a create view statement here, and what this view is going to do is to join together all of the tables that will list the courses required the earn each degree at our university. Along with some information about when a student is supposed to take each course during their time at our university. Let's go ahead and create this view right away. Now we can query this view. I'm going to put this query in here, and what this query will do is it will get all of the courses that one needs to complete in order to earn a Bachelor's degree in Computer Science. Let's go ahead and run this query. Down here we see our results. This probably looks familiar to all of us who had a similar study plan back when we went to college. What's nice about this though is when we use the view, I could just query the view, and this resulted in a much simpler sequel statement. I just needed a couple of where clauses to get the data that I was after. I didn't have to type in all of the tables that I was joining in a join criteria, like we see that's up here in my view definition. This is all encapsulated in the view, so if I go back down to the query that I used, this is much simpler. Internally, Oracle did go and expand out the view to query all of those tables and join the results together, but the syntax I was able to use to get my results was quite simple. This is an advantage that views provide, this simplification. There's something else that I want to point out in the view definition if we scroll back up to the top here. We'll close these lower windows so we can maximize our screen area, and that is that the department code column occurred twice in the sequel statement to define the view. This first time the department code is for the department that is offering the degree, and in the second instance, it corresponds to what department is offering a particular course that's required for the degree. What we can't have is two columns in the view that have the same name. Oracle doesn't allow this, and besides, it would be confusing anyway. What we need to do in these cases is give at least one of the columns an alternate name. What you can see I am doing here for the first occurrence of the column, and that will be called the degree department code so we're clear what this column means. You can provide an alternate name for any column in your view, not just the columns where you have naming conflicts, and you can see that I am also doing this for this column here, the department name. I'm renaming that to degree department name so it is clear this is the name of the department granting the degree, not a department name that's related to the course. Let's create a second view and explore another use of views. To do that, I'll start by cleaning all this up, and here is the definition for the second view that I'm going to create. In this view, I am getting all of the students who are current computer science majors at our university. Now I could just directly query these. Students table for this information, but maybe I have some reason why I don't want to allow another user to see all of the data that is in the student's table. I want to restrict access to computer science students, and I only want them to have access to the student's name and the email address, not other information that might be in that table, like the student's phone number, their date of birth, or their home address. Let's go ahead and create this view. We see that that view successfully created, so now we can query this view, and we'll run this query. You can see here in our results we have only a subset of the columns from the student's table. We also know that due to our where clause, and we can see in the results, we only have computer science majors in this results set. Now what we could do is we could grant permission to that other user to use this view and that would give them all the information that they needed, and we wouldn't have to grant permission to them to be able to see the student's table directly. Giving them permission to the student's table directly might provide them more access than what we're comfortable with, and we could have some information disclosure concerns there. This is a fairly common use of views to create a view so a user will have access to some of the information they need and know more.

Read Only Views

There is another option that you can use with your create view statement that I want to point out, and that is the with read only option that you can include at the end of the create view statement. We'll talk about DML statements in views in a moment, but by including the with read only option, you guarantee that your view is just that, read only. Creating a view could be used by a different user in Oracle. There are ways to control this with privileges on the view that you grant to that user. If however you really intend the view to be just for reading data, then the read only option is a good idea because it clearly expresses your intentions.

Views and DML Statements

The question always comes up about views is if you can end up insert, update, and delete statements against a view. As eluded to in the last segment, in certain situations you can execute a DML statement against a view. Let's explore this idea further. Let's start by understanding what situations you will not be able to run a DML statement against a view in. If the sequel statement you use to define the view contains the distinct keyword an aggregate or analytic function, a group by, order by, connect by, or starts with clause, or a subquery expression as one of the column values of the select statement, then you will not be able to run any DML statements against the view. Also, as you would expect, any view defined with the with read only option will not allow DML statements to be processed. What this is getting at is that the simpler our view is, the more likely it is we will be able to use it for a DML statement if we wish. Let's look at one of those scenarios. Let's take a look at the simplest case possible in which our view is just a wrap around a single table like the one shown on the screen. This view just narrows down the courses table to the computer science courses. Let's go ahead and create this view. There we go. First of all, I'm going to demonstrate when we have a very simple view like this, it often times is possible to update a record in the table. To do that, going to run this sequel statement here which is going to update CS2 12, our database systems course from three credits to four credits. Let's go ahead and run this statement, and we see Oracle came back and told us one row was updated. Let's go ahead and confirm that the data did actually change and we'll do that by querying both the view and the underlying base table. Here we see the data in our view, and if we scroll all the way out the right here we see this course is now worth four credits, and now if we query the table, and again scroll back out here to the right, we see the same thing, four credits. Remember the view doesn't actually store any data. All the view is doing is giving us a logical view on the data that is in that underlying base table, in this case the courses table. We're actually looking at the same piece of data here. I just wanted to make it clear that indeed this updated statement did modify the data that is in the base table. Now let's go ahead and demonstrate that on a simple table like this, that an insert statement is also possible. The first thing we'll do is we will clean up some of this area here in our sequel window, and here is the insert statement we're going to use. We'll insert a new course, a special topics course, and running this statement, it succeeds. I'll again, query the data back out so we can see that that data is indeed there, and there's our data. What's important to know is that all of the constraints that are on the underlying base table still apply. Let's try another insert statement, but this time we're going to leave out the course description in the insert statement. Then that would become a value of null, and in this particular table course description is required. It's defined as a not null column. Let's see what happens. There's our insert statement and you can see there's no course description specified. Let's go ahead and run this, and we see that we get an error. What this is telling us is that any constraints on the base table, those still apply. This is also going to be true of any default values that are specified. If we had defined our view without the course description column, then basically we wouldn't be able to use this view for inserting, because we wouldn't have any way of specifying a non-null value for the course description. What you want to keep in mind is even when you're doing DML statements through a view, especially insert statements. All of those constraints on the table do still apply. Whether or not you can meet these constraints or not through the view, is really what the determiner is if you can run a DML statement or not. As a last example, let's go ahead and delete a row from this view. What we'll do is we'll delete that course that we just put in the table, and we see that succeed we went ahead and deleted that special topics course that we just added. What this is telling us is that if we have a simple view we can indeed perform DML against the view. What's happening is that the view is just passing the DML statements down through to the table that it's wrapping. So long as we obey all of the constraints that are on that underlying table, our DML statements are going to work. A more complex case is when we have a view that joins together two or more tables. Let's talk about that situation next.

Views With Joins and DML Statements

If we have a view that joins multiple tables together, things get more complicated, but you still can potentially execute DML statements against these views in some limited scenarios. The general rule is that the DML statement will only modify a single base table, and the base table that will be modified is what is called the key preserve table. A key preserved table is a table in that every unique key of the table would also be a unique key of the resulting joint operation that is occurring in the view. What you want to do is to look at the unique keys of the base table in the view and figure out which if any of those could also serve as a unique key for the view, and this will identify the table that will be updated. If you run a update or delete statement against this view, this is the table where those will be affected. When running an update or insert statement against the view you can only include columns from this table in the statement, as this is the only table that will be affected. If you include columns from different base tables, then you will get an error. Let's see an example of this, because this should make things clearer. I've already created the view you see on your screen, Name department degrees, and I'll go ahead and select the data from this view real quick so we can see this data. Here's our data, and I'll move this up so we can see all of it. What's important to note here is the degree ID column. It is the primary key of the degrees table, and also can be a unique key for this view. This means that it is the degrees table that is our key preserved table. Any DML statements we would perform would impact the degrees table, and we would need to be sure to only include columns from the degrees table in our DML statement. Let's go ahead and prove that theory out, that we indeed can execute DML against this view, so long as we only include columns from the degrees table, and what I'll do here is I'll start with a select statement, and we see that that succeeds. I'll select the data out here so we can see our new row. Indeed, there it is. Let's go ahead and do an update, and again we see that this succeeds. Once again, the reason why these statements are succeeding against this view is because we're only affecting columns in that key preserved table, the degrees table, in these DML statements that we're running against this view. However, if we step outside of this boundary and we try to affect one of the other columns in a different table, we're going to run into trouble. Let's go ahead and demonstrate that. What I'm going to do here is I'm going to try to update the department name column, and this column is actually in the departments table. Let's run this statement, and we see that that fails and I get this error. When we have these joined views, we can only perform DML statements that affect the key preserved table, the table whose key would also work as a key for the view. It might be possible that there is no table that has such a key, and then we would not be able to perform DML against any of the columns in the view. It just depends on how you construct the view. Now to keep track of columns you can and cannot insert or update to can be a little bit tricky. Fortunately, Oracle does give us a data dictionary view to help with this task. We can look at the view user_updatable columns, and that's going to tell us exactly what columns we can and cannot update. Let's go ahead and see a quick example of that for this view. There's the statement, and we'll run this. And we can see, here we are, exactly what columns we can manipulate, and this agrees with our earlier results. If you're ever confused and you have one of these joined views, and you're not sure what columns you can or cannot affect with a DML statement, just take a look at this view. Overall though, if you're trying to conduct DML through a view that joins multiple tables together, you may want to rethink though if this is the correct approach. It can be a little bit tricky to figure out, and things that are tricky tend to lead to errors. I would encourage you to look at other approaches that are more transparent.

Views Using WITH CHECK OPTION

The last topic I want to discuss relating to views and DML is the with check option that you can include in your view definition. By including with check option in your view definition Oracle will check any rows that are affected by DML statements against your view and make sure after those DML statements have completed, the affected rows still will meet the conditions of the view. The best way to understand this is with an example. I have here the computer science courses view that we saw earlier, and for this first part, I'm going to create the view without using with check option. I'll go ahead and get this view created, and now I'm going to run a couple of insert statements against this view. As you can see, the first insert statement inserts a row for every new computer science course, and the second insert statement inserts a row for a new electrical engineering course. Before we even run this statement, our gut feeling tells us there's something that's a little bit wrong with this second statement, because we're inserting an electrical engineering course using a view called computer science courses. Let's run these statements and see what happens. The first statement runs successfully as we would expect it to. Now let's run the second statement, and that statement also succeeds. Again, this isn't what we're really wanting or expecting here. We would expect that we wouldn't be able to insert an electrical engineering course into this view. Let's see how with check option can help us. First what I'm going to do is I'm going to roll back the data so we can start fresh. Let's clean things up a little bit, and then I'm going to recreate this view using with check option There we go, that view has been recreated. Now let's go back and try and run our insert statements again. Our computer science course we're still able to insert, and again that's good. That's what we would expect. Now when I try to run the insert statement through insert an electrical engineering course, this was not allowed, because this electrical engineering course wouldn't be included in the view, and this is what with check option gives us is Oracle is going to look at the view and see if any row from a DML statement, in this case an insert statement would be included as part of that view, and if not, Oracle is going to disallow that DML statement. The same would hold true here if I tried to do an update statement, and I tried to update a computer science course to an electrical engineering course, because the result of that statement would be that the course would no longer be in the view. Using with check option, Oracle would disallow that statement. If you're conducting DML against your views, you might want to consider using with check option, because this is going to make sure that any rows that are manipulated will still be part of the view, and any rows that are inserted are also going to be part of the view which typically is a little bit more of what people expect.

Making Use of Views

Let's take a moment to pull together the entire discussion we have had about views. What a view really is is an object that encapsulates a sequel statement. In the output of the sequel statement that defines the view, gives you something that you can think of as a virtual table. While a view is really a very simple object, they can prove to be very useful. A lot of people tend to be turned off by the relational model where you normalize your data out into separate tables. There are good reasons to normalize your data in this way, but for someone who is not familiar with database principles, finding all of the tables they need for a query and joining them together can be a challenge. Even for individuals with a lot of database experience, writing the same join conditions, where clauses or aggregate functions over and over again can be quite repetitive. With a view though, you can solve both of these problems by creating this logical view of your data and thereby providing a simpler facade to what's actually going behind the scenes. This can proved to be very useful. What is important to remember though is that a view is just a logical object. A view does not store any data or have any tables prejoined or anything like that. It's just a logical abstraction, and when you use a view in one of your sequel statements, what Oracle will do is substitute into your statement, the definition of the view. While this is convenient for us writing sequel statements, it does not result in any sort of performance increase or anything like that. One of the main strengths of views is that we can hide the complexity of a sequel statement behind a view, but this can also be a downside as well. If you find yourself encapsulating business logic in a view through the use of subqueries for column definitions, complex analytic functions, or other complex sequels, you might want to stop and ask yourself if a view is the right construct for what you are trying to accomplish. In software and system engineering, whenever we get too much logic and complexity in one structure, we usually start to run into trouble in terms of maintainability of that structure. Over my years in IT I've seen some people develop views that encapsulates some very, very complex sequel. In those cases I often felt that they would have been better served to balance that complexity across multiple layers, or employ some different design techniques. Rather than creating a super view of all the data they could potentially need. This should not dissuade you from creating views in your database, but serve simply as a reminder that designs that are simple, expressive, and easy to understand almost always are more maintainable in the long run. The final thoughts I will share with you are around using DML in views. As we saw, you can execute at insert, update, or delete statement against a view. I would encourage you though, if you choose to do this, keep the views that you use, DML against simple. Preferably wrapping a single table and interacting with that table in an obvious way. If this doesn't work for you, look at another approach. Perhaps like a store procedure or incorporating the functionality you need into your applications data to access later. It is possible to execute DML against some of the more complex views that we've seen. It is often difficult to understand what is happening at first glance. This is not the hallmark of a maintainable system. Again though, don't let this dissuade you from using views in your database. Used properly, views can simplify repetitive queries and help you give more meaningful names to poorly named tables and columns. Views are a great way to limit access for a user to only the data that they need to see. As you design and work with your databases, you will find that views are a useful tool for when you need a logical view of your data that can't be directly found in your tables.

Summary

In this module, we talked about views in Oracle which can form a logical facade over your table data to give you a type of virtual table that you can interact with. We started off by discussing what is a view, and what are some scenarios where you would want to use a view. We then continued with how you create views, and then we spent quite a bit of time talking about views and DML statements, like inserts, update and delete. The scenarios where you can and cannot use DML statements against views. Finally we wrapped up with some tips about how to use views in your database. In the next module, we're going to continue our discussion of some of the other types of objects in Oracle, including synonym sequences and triggers that you may encounter.

Synonyms

Introduction

Hello, my name is David Berry. Welcome to this module on Synonyms in Oracle. In this module we're going to start by talking about what a synonym is in Oracle and why you might want to use one. We'll then discuss how you go about defining a synonym in your Oracle database and finally we'll finish up with a couple of demonstrations of how you can define and use synonyms to tie everything together.

What Is a Synonym?

Oracle allows you to define an object called a synonym which is just an alias for another object in Oracle. Most commonly a synonym is used to create an alias on a table or view, but you can also use synonyms for stored procedures, functions, packages, sequences, or even another synonym. The most common use for a synonym is to create an alternate, more meaningful name for an object in one of your databases. Maybe you have a table or stored procedure that doesn't comply with your naming standard or whose name does not really reflect what the object does and therefore causes some confusion. You may have a lot of existing application code or stored procedures that already point at this object so trying to rename the object would be a time consuming task in terms of all the code that you would need to modify and test. With a synonym you can create an alias of a more meaningful name and then simply use this alias name everywhere you would have used the original object name instead.

Synonym Types

There are actually two types of synonyms in Oracle, private and public synonyms. A private synonym is a normal synonym that is only defined for the current user. So it is just the user who created the synonym who has access to use the alternate name for the object. This is the most common type of synonym that you will create yourself or encounter in Oracle. A public synonym is a synonym that is available to all users in Oracle. Every user in the database is able to use the alternate name of the object in their sequel statements. To define a public synonym, you will need the CREATE PUBLIC SYNONYM privilege. This is privilege that is not normally granted to users because a public synonym is sort of a global object. So if you think a public synonym is appropriate, talk to your DBA and they can create the synonym for you or grant you the appropriate privilege.

Synonyms and Object Permissions

You should know that creating a synonym does not do anything to alter the permisions on the aliased object. That is, all a synonym is doing is creating that alternative name to reference the object by. All of the permissions on the underlying objects still apply and Oracle will check these permissions on any SQL statement that executes against that object. So for example, a public synonym may have been created for a table in your Oracle database, but any user in the database will still need the appropriate privileges to select data and modify data in this table. A synonym being defined for the table does not effect this. It is simply an alternate way to refer to the object.

Creating Synonyms

The syntax to define a synonym is very simple. You simply say create synonym followed by the name of the synonym, the keyword for, and then the name of the object that is being referenced by the synonym. If you are defining a synonym on an object in a different schema, then this needs to be the full name of the object, schema name and object name so that Oracle can locate the object. Finally, you do need to know that you need the create synonym privilege in order to create a synonym. If you are creating a public synonym then you would also include the keyword public in your definition. Again, to do this, you will need the create public synonym privilege granted to you. Notice in both cases we can use the create or replace synonym syntax which means that if the synonym already exists, Oracle will simply replace it with the definition that you are supplying in this statement. This is a nice convenience so you don't have to check if the synonym already exists, you can just override it with a new definition if it does.

Synonyms and Objects in Other Schemas

One of the most common uses of a synonym is to create aliases for tables you may be accessing in another schema. Let's say that we are longed in as the user's student, but we need to access a table named rooms that is located in a different schema, the facilities schema. For this example we'll assume all appropriate permissions have been set up on this table. What you would need to do in this case is write your query like this, qualifying the name of the table with the name of the schema where the table is located. However, what you could do is create a synonym in the student schema and then you could use this synonym in your SQL statement thereby not having to remember to include the schema name with the table name. This query is actually referencing the synonym which in turn references the table. There's no difference in terms of performance or permissions. What a synonym really gives you is convenience. The convenience to define a shorter or more meaningful name to use to access an object in your database. Let's look at a demonstration of using synonyms in a database.

Demo: Creating and Using a Synonym

A synonym allows you to define an alias or alternate name for an object. So let's do that. I have a table here called faculty_mbr that contains all the faculty members for my fictional university and you can see some of those results at the bottom of the screen. Notice though that in this table name, I have an abbreviation mbr where as in all my other tables I have spelled out the words completely. So maybe someone who created this table didn't follow the naming conventions we had in place and now this is causing confusion because we have to remember that this one table doesn't adhere to the conventions as all the other tables do. You might say, why don't we just rename this table, but maybe this table's been around for a while and we have a lot of application code and stored procedures that have this name embedded in them and it's really not feasible to go and update all of that code. So what we're going to do is we're going to create a synonym to make our lives easier so we can use the name that we're used to but not break any existing functionality. So let's go ahead and do that. So we see here for this synonym we're going to have faculty_members as the name and that will serve as an alias for our target object, that name with the abbreviation in it, faculty_mbr. So let's see what this gives us and we'll go ahead and modify our query to use this synonym name. And we can see now this works. The query's actually using the synonym which in turn looks at the table. So I can use the fully spelled out name in my SQL queries or in the applications I write and I don't have to remember that this one table is named differently. What's also good about this though is if I go back through the original name that's still going to work and I'll demonstate that to you now. And we see indeed that that original name does still work because now we're just accessing the table directly. So this is a very useful application of synonyms.

Demo: Using a Synonym for Objects in Another Schema

Let's do a second demo with synonyms and this time we're going to use a synonym to assign a friendly alias to a view that is in another schema. So just like in the slides I'm logged in to SQL developer as the user's student and what I'm looking to do is I'm looking to access a view in the schema facilities called all classrooms. Since that view is in another schema, when I try to access it in one of my SQL statements I need to do it like this where I preface the name of the view with the schema name where the view's located. And this is true not just for views but tables, stored procedures, or any other object type in Oracle. So let's go ahead and run this query to show that we do indeed have access to this view. And we see our results here on the screen. We've got various different classrooms in our university and this data set. Now let's look at what happens when someone forgets to include the schema name in their SQL statement. So we'll try that next. So I have this query and you can see I don't have a schema name on the front of the all_classrooms view name so I'll run this statement. And we see that this fails, and the reason why this fails is because Oracle's looking in our current schema for the object all_classrooms and it's not finding it. It doesn't know that it needs to go and look in the facilities schema unless we explicitly tell Oracle that that's what it needs to do. So we can do that and include the schema name like we did in the first query and as we saw, that works perfectly fine but we can also use a synonym here to make things a little bit more user friendly and also save ourselves some typing. So let's go ahead and do that. So here's the synonym that I'm going to define. So let's create this synonym and so now that's been created, so let's go back and try this second query where we didn't qualify the view name with the schema name. And so we can see now this works and what's happening here is that Oracle is locating the synonym and then in knows that the synonym is really an alias for the view that's over there in the facilities schema, so now Oracle's able to locate that view that we want to query. in the end what this provides us is a little bit of convenience. If you have tables or views like this in another schema that you're frequently accessing, this is nice because it saves you a little bit of typing and you also don't have to remember to qualify these object names with the schema name every time you write a SQL statement.

Summary

A synonym in Oracle allows you to define an alias or alternate name for an object in Oracle and when we say object, we are not just limited to tables. Synonyms can be defined for views, stored procedures, functions, packages, and sequences as well. This is useful when you have a situation where one of these objects has a poor name but you aren't able to rename the object because of existing dependencies. You can use a synonym to define an alternate name for the object that is easier to work with while leaving the existing name in tact. Finally, synonyms can often be useful when working with objects located in other schemas because you can use a synonym to create a local alias for the object and need not worry about including the schema name for the object in each of your SQL statements.

Sequences

Introduction

Hello, my name is David Berry. Welcome to this module on sequences in Oracle. In this module, we're going to cover Oracle sequences. We'll start with what a sequence is, and where you would use one. We'll then cover how you can create a sequence in Oracle, the options Oracle gives you, and what these options mean. We'll then talk about how you access the values in a sequence, both if you are in just plain old SQL, or if you're writing an application in a language like C#. Finally, we're going to discuss sequences and transactions, and how even if a transaction rolls back, sequence values are not reused, and the implications of this.

What Is a Sequence?

Using an Oracle sequence object, you can generate unique integer values for any process that needs them in your system. A sequence in Oracle is guaranteed to be thread safe, so no matter how many different sessions you have connected to Oracle using a sequence to generate unique values, those values are indeed guaranteed to be unique. The most common use case for using a sequence has been to generate values for a surrogate primary key. That is a primary key that is just a unique auto-generated number. You can call the sequence directly to get the next value as you see here, or oftentimes, people will define a trigger to access the sequence and automatically insert the unique value into the table. Up through Oracle 11g, Oracle did not contain an identity data type, so it was common to use a combination of a sequence and a trigger in this way. However, Oracle 12c does contain an identity data type, which internally just uses an Oracle sequence to generate integers for an auto-number column. Consequently, you might find yourself directly defining sequences less frequently in Oracle 12c and future versions of Oracle. However, you will still run into sequences in lots of Oracle databases, and sequences do form the basis of the identity data type, so it is good to understand how they work. This, however, is not the only use for a sequence object. Let's say, for example, we have multiple instances of a process that are all running on different machines, and between these processes, we need to generate a value that is globally unique, for something like a transaction ID or a session ID. We certainly could use something like a guid, but if we wanted this to be some sort of numeric value, we would find out that if we try to write code to do this, and coordinate between all of these different machines, this is actually a very difficult problem to perform this coordination. So, one solution would be to use an Oracle sequence object, so that whenever a machine needed a unique value, it would query this sequence object in Oracle to get that unique value, and we could be confident that this value is safe for multiple processes, and this will be durable across any of the machines being restarted. So, any time you need to generate a unique value across processes or machines, keep in mind that you could also use an Oracle sequence to perform this task. Let's look at how we create sequences in Oracle, and then we'll discuss how you make use of sequences in your code.

Defining Sequences

To define a sequence, we usually create a sequence command. We then specify a name for the sequence, and that is all that is technically required. What this will do is generate a sequence that starts at one, increments its values by one, and has a cache size of 20. And in most cases, these defaults work just fine. As you see though, we do have a number of other options, so let's look at what all these different options mean. First, we have the INCREMENT BY clause, and this specifies the value the sequence should count up or down by. By default, this value is one. If we want to count up by tens, we would specify 10. If we want our sequence to count backwards, then we would set this value to a negative number. The next option is the START WITH clause, and this defines the initial value that our sequence will start with. If you're using a sequence to create values for a surrogate primary key in a table, you will have occasions where you may already have some data in that table, and so you'll want to use a START WITH clause to set the initial value to greater than any existing value in the table to avoid collisions with existing values that are already in that table. The next option we'll discuss is the CACHE option. This specifies how many sequence values Oracle will pre-allocate and keep in memory for fast access. By default, the value is 20. If you don't want any sequence values cached in memory, then you could use the NOCACHE option. However, then every time the sequence is accessed, a disk read will be required, so this is generally not a good idea from a performance standpoint. The next two options are different sides of the same coin: MINVALUE and MAXVALUE. Not surprisingly, these specify the minimum and maximum values that can be generated by a sequence. Ascending sequences, by default, have a minimum value of one and a maximum value of 10 to the 27th. Descending sequences have a max value of minus one, and a minimum value of -10 to the 26th. Generally, you don't need to set these values, and the takeaway here is that sequences in Oracle can support the generation of a large number of unique values. Finally, we have the CYCLE option, which specifies, if you do get to the maximum or minimum value of your sequence, then the sequence should wrap around and continue generating values from the minimum or maximum, depending on if your sequence is ascending or descending. If you do not use the CYCLE option, then the NOCYCLE option is set by default, which means that, if your sequence gets to its maximum or minimum value, and you try to get another number from the sequence, Oracle will give you an error.

Accessing Sequence Values

To get a value out of a sequence object, there are two functions that we use: nextval and currval. Nextval is the function that you will use most often, and it gets the next value in the sequence, the next unique number. In this example, we're just calling nextval on the sequence in the context of a query using the DUAL pseudo-table. If you created a sequence and ran this query in your SQL editor, what you would see is that Oracle would increment the sequence to get the next value and then return that value to you in your results pane. The currval function can only be called after you've called the nextval function at least once within an Oracle session. And currval will give you the current value of the sequence, which is the last sequence value that was generated in this session. This becomes clear when we look at some SQL statements that use these functions, so let's do that. The most common approach is to have an INSERT statement, like you see on your screen. In this table, we have an ID column, where we just want a numeric identifier, and so, for the value, what we do is we use the sequence with the nextval function, which will get the next unique integer from the sequence and insert it into the table with this row when the statement executes. Then, if we need to get that sequence value back, we can call the currval function on the sequence. And here you see that we're using the Oracle pseudo-table DUAL in order to facilitate this query, and what this will do is give us back the value that was just inserted into the table in case we need that for some subsequent processing. So what would some application-level code look like that uses a sequence value? Here I have some C# code. If you're working in Java or any other language, the code that you would use would be very similar. Up here, I have my INSERT statement defined, and we see the same syntax that we saw on the previous slide, where we're using the nextval function on the sequence in order to get the next unique value and include it with the row that we're inserting into our table. So then, scrolling down to the actual method that performs the insert, we see that, first, we're going to create and run a command to go ahead and execute that insert. Then, we're going to run a second command, which is just the SQL statement that we saw earlier that will use the currval function to fetch the current value of the sequence, that is the last generated unique value, and retrieve that value back into our C# code. In this case, we are assigning that generated value to the StudentId property of our Student object in C#. So, this way, our C# object will be in sync with what we have in the database. What is important to note is that both of these commands are running on the same Oracle connection, so we know that these two commands will be run as part of the same session in Oracle. If we don't do this, then our currval function isn't going to work, because, remember, it needs to be called in the same session to get the last value of the sequence generated. Let's move into a demo where we create a sequence and insert some rows using the values generated from the sequence.

Demo: Creating and Using Sequences

Let's do a simple example with sequences to put into practice what we have learned. I already have this simple students table created that you see on your screen, and you'll notice in this we're not using an identity column to populate the student_id values. We're going to use a sequence to do that instead. So, let's go ahead and create our sequence that we're going to use for this, and for this, we're just going to use the minimal sequence declaration. And so we'll go ahead and create this sequence. And so, now, if we want to get the next value from the sequence, what we can do is just use the nextval function. So let's go ahead and do that. So, a simple query like this, we're just calling nextval on the sequence, and let's run this query. And so we see, here's our value, and not surprisingly, that is the value of one, because we just created the sequence and we're getting that first value from the sequence. Of course, what our real interest is, is to use a sequence to create the student IDs when we insert rows into the table that we have. So, let's go ahead and do that. So, here we have an INSERT statement that we're going to run, and we notice the sequence next value down here in the INSERT statement. So, let's go ahead and run this. So, now our row has been inserted, so let's go ahead and take a look at that row in the table. And there it is. We can see that the next value in the sequence was the number two, and the reason why the number two was used is because, remember, we already called nextval once in that SQL statement before. So the value one had already been generated by the sequence and that was already used. When we ran our INSERT statement, Oracle went to the sequence to get the next unique value, which was the value of two, and that's what was used in this INSERT statement. So, let's say now that we needed to know what the last value generated in the sequence was, and we might need to know this because after inserting this initial row, maybe we need to get that value back so we can do some subsequent processing, like inserting some child rows of this record in some other tables. And so, in order to do that, we can use the currval function on the sequence. So, this query will do this; notice the use of the currval function here, and we'll run that query. And there we see the value of two. So we can use this statement for those situations where we need to get the last value generated by a sequence. Remember two things: first, this is the last value generated within this Oracle session. And secondly, you will need to have previously called nexval within this Oracle session. So, what this is really targeted at is getting the last value generated by a sequence within this session. Let's go ahead and do one more insert on the table, and what I want to do is show you here that calling currval, that doesn't increment the sequence; all it does is retrieve a value. So, we'll go ahead and insert another row. So, here's our INSERT statement and we'll run that. And we see we've had a second row inserted, so let's go back and we'll query now the data out of our students table. That was this statement right here. And, indeed, we see that we have the value of three assigned to this row.

Sequences, Transactions, and Gaps

As we have alluded to in this module, once a number is generated from a sequence in Oracle, that value is never re-used. And this is true even if that value was generated inside of a transaction that is subsequently rolled back. Consider the following situation, where we have a series of transactions, which each generate a value from a sequence. However, as we see, two of these transactions, transactions three and five, do not commit, but rolled back. Notice though, that the sequence values three and five, are not reused in subsequent transactions. Transactions four and six get newly generated values from the sequence. So if we were using the sequence values to insert into a table, when we queried the data from that table, we would notice there would be gaps in the values of the column where the sequence value was inserted, namely, the values three and five would be missing. So, there are two important takeaways here: first is that values generated by a sequence are not ever reused, even if the enclosing transaction is rolled back. And secondly, you are assured to get unique values, but you may end up with some gaps between those values. So, what you end up with from a sequence is unique values, but not necessarily contiguous values. Let's do a quick demonstration in Oracle to show that this is the case.

Demo: Sequences and Transactions

We'll do a quick demonstration to show that once a value is generated in a sequence, then that value is never reused, even if it was generated inside a transaction that is then rolled back. You see on your screen the example students table we are now very familiar with, and the sequence. And what I have done is I have dropped the table and sequence in my database so that we can go ahead and create fresh copies for this demonstration. Also, I will remind you, by default, the INCREMENT BY value for a sequence is set to one. So, let's go ahead and create these objects. There we go, those objects have been created. Now let's insert some rows into this table, and what we'll do is we'll do a series of INSERT statements to do this. So you see the INSERT statements on your screen, and what you'll notice is that after each one of these statements, I'm issuing either a COMMIT or a ROLLBACK. Statements one, three and five will be committed to the database, while statements two and four will be rolled back. So what we expect here is that when we look at the data in our table after running these INSERTs, we'll see student records with the IDs of one, three and five, but not two and four. And what is important here is that even though the sequence values two and four were in transactions that were ultimately rolled back, these values don't get reused. Oracle just moves on to the next value. So, let's go ahead and run all these INSERT statements and show that this is the case. And now that our data's inserted, we'll go ahead and take a look at it. And, indeed, things are exactly as we expect. We don't have the values two and four in our table. So, while these student ID values in our table are unique, they're not contiguous. In this case, we're just using these values to populate the value of a surrogate primary key, and remember, the definition of a surrogate primary key is that the value doesn't have any domain meaning; it's just a unique number assigned to the row. So, the fact that there are gaps in the numbers here is not really an issue for us. If we did need numbers that were truly sequential and did not have any gaps, we would need to look at a different approach. But in many applications, it is simply unique values that you're after. And in these cases, a sequence works just fine.

Summary

In this module, we have discussed sequences in Oracle. A sequence object allows you to generate unique values in a thread safe way. And the advantage of this is that Oracle has already done the heavy lifting for you, making sure the values that are generated are indeed unique, no matter how many processes may be generating values at one time. If you've ever had to write code that is thread safe, you know this can be quite challenging. So, using a sequence saves us a lot of trouble in terms of having to write code that does this. We then talked about how to define a sequence and what the most important options mean. Next, we talked about how to access values from a sequence and use them in the code that you write. And finally, we talked about sequences and transactions, demonstrating that even if a transaction is rolled back, sequence values are never reused, so you know that the values from a sequence will be unique.

Triggers

Overview

Hello, my name is David Berry. Welcome to this module on triggers in Oracle. A trigger is a construct in Oracle that allows you to execute an action when a statement is executed in your database. Typically this is a DML statement and that is the scenario we'll spend the most time on. But as we'll see there are some system events that you can also attach a trigger to. This gives you the ability to intercept certain events in your database and perform additional logic when those events occur. For example, you may want to manipulate the values of a DML statement that is running as a certain table or perform some other action, like updating another table and triggers give you the ability to do this. In this module, we'll start out by talking about some of the scenarios that triggers are commonly used in. We'll then continue with a discussion of the different types of triggers that you can create. Next we'll look at the syntax around how you define and manage triggers in your database. We'll then work through a number of examples of triggers to see how they work and put into practice what we've learned. And finally, we'll finish up by discussing compound triggers, which is a type of trigger that allows you to share variable scope across all of the different trigger firing points and can be quite useful in some scenarios.

Where Triggers Are Used

Before we dive into the syntax of how to define a trigger and the options available. Let's understand some of the scenarios where it might be useful to use a trigger. The first situation is that you might need to update one of the columns on your table that's used for administrative purposes. Think of a column, like last modified date. You can define a trigger as such that whenever a row was inserted or updated in the table, the trigger would correctly populate this field. Another very common use in Oracle, is that prior to version 12C, Oracle did not contain auto-incrementing identity columns like other databases did. What you could do though, was synthesize the same behavior with a combination of a trigger and an Oracle sequence. You will still run into this quite often because many of the databases that are running in production today, were designed before Oracle 12C was available. Another common use for triggers is to log events that occur on a table. We may want to keep a separate archived table where every time a row is updated or deleted in our main table, we put the old version of the row into that archived table and this is something that can easily be accomplished using a trigger. The final reason to use a trigger is to enforce some complex business constraints that cannot be enforced using normal table constraints. Say for example, you wanted to compare a value inserted or updated into a table with a value in a range stored in a different table. This is something you couldn't do with a normal table constraint but you could accomplish with a trigger. Now you should know that there's always a lot of debate about triggers in the database and application development communities about what their appropriate use is. One of the issues with triggers is that this is a separate construct where you can place code and when you're tracing through the logic of an application or a stored procedure, most people are thinking about the logic that is in the program or procedure that they're tracing through, and not what a trigger might be doing. And so this can cause some confusion because when looking at your application or stored procedure code there is nothing that's readily apparent to indicate that there's also behavior that is defined in a database trigger. So it's very easy for someone to miss this, especially when we're developing the business logic for our application. We tend to like to keep our code cohesive. Where all of our logic is defined in one component and not scattered through different components in our system. For this reason, I try to make sure that I don't have any business logic defined in triggers. When I use triggers, it is usually around an administrative purpose, like archiving old versions of rows from a table or making sure the latest modified date column is updated correctly. And in these cases, a trigger makes a lot of sense because these are actions we want to occur no matter where a sequel statement is being executed from, whether one of our applications or in a sequel editor.

Types of Triggers

Before we get into the syntax about how to create triggers, let's first understand the different types of triggers available in Oracle. The first type of trigger is a statement level trigger and the type of statements we are talking about here are DML statements. So inserts, updates, and deletes. The logic inside the trigger will execute exactly once. No matter how many rows are affected and this will occur either before or after the statement executes depending on your definition of the trigger. Next we have row level triggers and in this case, the logic in the trigger will execute once for each row that is affected by the DML statement. So if we perform an update for 100 rows, the trigger will fire 100 times, once for each row. Within our code for a row level trigger, we'll have access to both the existing and new values for each column in the row and this turns out to be very useful. Finally, we have system triggers, which occur on system level events, like log ins and log outs, or schema level events, like creating or altering an object in your database. System level triggers are really aimed at DBAs and not developers. So we will not be covering them in this module except to let you know that they do exist.

Defining Triggers

To create a trigger, you use the create trigger statement. As you see here, this statement also supports the create or replace syntax, so that the trigger already exists, it would be replaced by this definition. In this example, the syntax that you see to create a trigger is for a DML statement executing against a table. And then, we need to specify the conditions for when the trigger will execute. We start by choosing either before or after, and we'll cover before or after what here in a second. Then we choose the type of statement this trigger will execute on, an insert, update, or delete. If we want the trigger to execute on multiple statement types, say like an update and delete, we can do that by using the or keyword between the two statement types. So the statement here would read update or delete. The next part of the statement defines what table you want the trigger to be defined on. This part of the statement is required. Triggers are defined against one and only one table. You also see on the line above the on table clause where you can optionally define a trigger to only fire for a certain column, and where this would make sense is if you wanted to capture events just about a certain column being updated. The last clause before we get into the actual logic of the trigger, is the for each row clause, and this clause is optional. If you don't include this clause, you will get a statement level trigger. So a trigger that just fires once, either before or after the statement. If you include for each row, then the trigger will fire before or after each row affected by the statement. From here, you're going to define the logic that the trigger will actually execute and this is just PL sequel code like you would write if you were writing a stored procedure in Oracle. Now there are a few special values you have access to in a trigger and we'll talk about those next. If you have a trigger that will fire for multiple types of DML statements, like the trigger shown on your screen. Then you may have a need to know what type of DML statement is executing inside of your trigger body. So within the body of your trigger, you can use a case statement with the keywords inserting, updating, or deleting, like you see on this slide. Notice also, there is a version of updating that takes a column name, so you can determine if a particular column is being updated. What this allows you to do, is execute different logic for each statement type that the trigger is firing on. Another thing you could do, is you could set the value of a variable to keep track of what type of operation is happening against the table and then use that variable later in your trigger code. When you were using row level triggers, you had the opportunity within the trigger to access both the current and new values of the row. And this is very useful if you need to compare the values of the two versions of the row or perform some other sort of operation against the data. In the example you see on your screen, we are taking the current value of the row and we're inserting it into an archive table, and the way that we are doing this, is by accessing the old pseudo record for this row via the syntax ;old. If we wanted to access the new values for this row, we would use the syntax ;new to access the new pseudo record for the row. And indeed we can access both the old and new records within the same trigger body. When working with pseudo record values, you want to keep in mind what data is available in those values based on the type of statement that is being run, and that is shown in the chart on your screen. For example, when you're performing an insert statement, all of the values in the ;old pseudo record are going to be null because there is no existing, corresponding row in the table. In the new pseudo record value, you have access to the values that will be in the table after the insert statement completes. You also want to know, that triggers cannot change the values in the old pseudo record. These are values that are already in the table and if you try to change one of these values, you will get an error. However, you do have access to these original values, such that you can perform comparisons to these values or archive them off into another table as need be. If you have a before trigger, you are able to manipulate the values of the new pseudo record. This gives you the ability to replace or modify values as need be and we'll see some examples of this in the demonstrations that we're going to do in a few minutes.

Enabling and Disabling Triggers

There may be times when you wish to disable a trigger and to do so, you simply say, alter trigger, the trigger name, and the keyword disable. If you want to disable all the triggers on a table, then you can use the alter table statement with the name of the table and the expression disable all triggers, When it comes to re-enabling a trigger, the syntax is just the opposite. We can say alter trigger, the name of the trigger, and enable. We can also enable all of the triggers for a table, simply by using the enable keyword in place of the disable keyword in an altered tabled statement.

Triggers and Transactions

One of the items that you want to be aware of is that you are not allowed to issue a commit or rollback statement within the body of a trigger or any function or procedure that is called by the trigger. If you do this, when the trigger fires Oracle will give you an error. Any statements executed by and logic performed by the trigger, have the transaction scope of the DML statement that caused the trigger to fire in the first place. Having a commit or role back statement within the trigger itself, would violate this transaction scope, so that is not allowed in Oracle.

Firing Order of Triggers

As we have eluded to in this module, it is possible to have multiple triggers on one table. When this happens, you will want to understand the order in which the triggers fire in, which is shown in the chart on this page. First will be the before statement triggers, followed by the before each row triggers, then the actual DML statement will execute. After this, the after each row triggers execute, and finally, the after statement triggers. Now it is possible that we might have multiple triggers defined for any of these different firing points. For example, we might have two triggers that execute in the before each row firing point and in these cases, it may be important to control the order in which these triggers execute in. We can do so using either the follows or proceeds keywords in our trigger definition. On your screen, you see that we do indeed have two triggers that both execute before each row on the same table. In the definition of trigger_two, the trigger at the bottom of the slide, you see that we can specify either follows or proceeds and then the trigger name that the execution order is dependent upon. And what this will do, is it will control the order in which the triggers execute. If you do have multiple triggers in the same firing point like this, I encourage you to explicitly specify the order you want the triggers to fire in using these keywords. This assures that you understand exactly what order things are going to happen in and you'll always get the results that you expect.

Demo: Updating Administrative Columns With a Trigger

Let's do a demonstration, where we have a couple of administrative columns on a table, create_date and modified_date, and we want to use a trigger to make sure that these two columns always reflect the proper values. What this does is that when we run sequel statements against this table, we don't have to worry about including values for these columns in our DML statements. The trigger will automatically take care of this and put the correct values into the table. And this is going to be true of sequel statements that we run from a sequel editor, or any statements that we run from an application using a technology like ADO.net, or JDBC to access our database. So we see the table here on our screen and the two columns. So let's take a look at the trigger. The first thing that we see, is that this trigger will fire before an insert or update statement on the student's table. In this case, we want to intercept the statement before it gets to the table so we can put the proper values in the table. So firing before is the correct choice. We also see that this is a role level trigger and that is important because in this case, we want to populate the values of the create_date and modified_date columns for each and every row affected by a DML statement. Moving down to the logic, we see that what we're doing is we're using the case when syntax that we saw earlier to determine if we are inserting or updating a row. If we're inserting a row, we want to set both the create_date and modified_date to sysdate, the current time on our Oracle server. If we're updating, we set the modified date to sysdate, but what I'm doing on the first line of the updating log is I'm setting the create_date value to the old create_date value, and the reason why I'm doing this is to prevent someone from modifying the contents of the create date column once the row exists. So even if someone comes in and tries to update a row and supply a value for the create_date column that's not going to matter here, we're just going to use the original value anyway. So let's create this trigger and try it out. And there we go, our trigger's been created. Now I'm going to insert a couple of rows into this table but I should let you know, I actually already have a pair of rows in this table. So the rows I'm going to be inserting here are actually rows three and four. That other pair of rows we're going to use in the second part of this demo. So let's go ahead and take a look at the rows that we're going to insert right now. So we see in these two statements, the first statement is not specifying a value at all for either the create_date or modified_date columns and that's okay because the trigger is going to take care of this for us. In the second statement, I'm supplying values, but these values are far in the past. So maybe this is a typo or a coding error but we don't want to actually use these values that are being supplied, we want to make sure that we have the correct values in these two columns. So let's run these two statements and see what we get. Actually ran the second statement and now I'll run the first statement here. Okay, both of those statements have been executed and those rows are inserted. So let's take a look at the data in the table. We'll scroll out just a little bit here. And we can see that for both of these two rows that we just inserted, we have the current date and time for both of our columns. So this is what we want. If we don't supply a value, we get the correct date and time for each of these columns or even if we supply an incorrect value, that doesn't matter, because the trigger's going to be intercepting these statements and making sure that we get the correct value in these columns. Now the second scenario that we want to try is the update scenario, where if we update one of these rows in the table and I have a couple of update statements that are going to modify the first two records that are already in the table, so students one and two on top here and you can see that the create and modify dates for those are back in 2014. So let's take a look at our update statements and we'll run those and then we'll see what happens. So here are our update statements and we see that the first statement is just a simple update. We're simply updating a user's e-mail address here and so what we're expecting here is that the modified date column should be automatically updated for this student to reflect the current date and time. In the second update statement, we're trying to modify the e-mail address and then also the create_date student for record number two. The update of the e-mail address is okay, but as we said previously we really don't want to allow people to update the create_date value that is in the database. So in this case, what we're going see is that the trigger that we have is going to keep this column from being modified. So let's go ahead and run these statements. And there we go, we see that both rows have been updated. And now again we'll query out the results. And scroll over here to the right. And so we can see that for both of these rows our modified date has been updated to the current date and time and that's what we wanted. We see though that for the second row, our create date did not change from its original value. And again, this is what we were after because once we have a value in that column, we want to preserve that value and not let anyone change it. So you can see from this example, this is a place where triggers can be very useful in taking care of these administrative type columns that we have in our tables.

Demo: Archiving Rows With a Trigger

In this example, we're going to add a trigger to our same students table and this trigger is going to archive data into a second table whenever a record is updated or deleted in the original table. In this way, we'll have all of the current records in the primary table, which is shown on the left of the slide here and we'll have a change history over in this archived table on the right of the slide. So if we need to look back and see when a row changed or what the value was on a certain date, we'll be able to do that. You see these two tables on your screen and how the data is going to be mapped when a row moves from the main table to the archived table. So let's take a look at a trigger that can accomplish this for us. So on the screen we have our trigger definition. This time we're going to fire after an update or delete statement. So at this point, we know we were able to successfully update or delete the rows in our table and we didn't run into any problems with violating constraints or anything like that. Once again, this is a row level trigger because we want to capture each row that's being affected and put that into our archive table, and then you see in the declarations section, I'm creating a variable to use within the trigger and this will just store a code that represents what type of statement was being run, an update or delete statement. And we see where that is getting set down here in the main body of the trigger with these case when statements. Finally, we see the insert statement that is going to insert the old values from the row over into the archive table. So let's go ahead and create this trigger on our table and see it in action. And there we go, the trigger's been created. So now what we want to do is we want to go ahead and run an update statement against the student's table and we should see a version of that row, the old version of the row move over into the archive table, so let's do that. So here's a simple update statement, which is going to update this student's e-mail address and phone number, and we'll go ahead and run that statement, and we can see that we updated a row in our student's table and now let's take a look at our archive table. So this sequel statement will take a look at the archive table for us. And indeed we do see a row in there and we see that this has the old e-mail address and the old phone number in it, and if we scroll out here we can see that we have some dates and time the way that we've designed this about when this row was actually active in the table. So in this way, what we're going to have is we're going to have a history of all the versions of this row that were in this table and that sometimes can be very useful or can even be required from an audit point of view. Now this will also work with delete statements, so let's go ahead and try that out. I have a delete statement here, and we'll go ahead and we'll run this. We see the row was deleted. And if I query the student's table, I can prove that to you. We see that we no longer have student number four, but if we go and we look in our archive table now. We see indeed there is a record of that student over here in the archive table and once again, we have all the information about when this row, this version of the row, was over in our main table. So this is a pretty typical use of triggers to have a sort of archive like this. What we will see in another demo in this module, is how to accomplish the same thing with compound triggers, which you might want to do from a performance standpoint. What this trigger is doing, is it's operating row by row, which is fine if we just have a lot of simple updates and deletes as we're seeing here. But if we're doing bulk updates and deletes, the compound trigger will give us better performance. So we'll take a look at that in a moment.

Demo: Creating an Auto-Number With a Trigger

In the demos in this module, I've been using a student's table that looks like the one you see on your screen and one of the things that you notice about this table is that the student ID is just a number column. I'm not specifying the column to use in auto-incrementing integer or anything like that. So when we insert a row into this table, we need to make sure that we're inserting a unique integer along with the row. In Oracle 12C, we can specify this column as an auto-incrementing column, and that's a feature that you also see in other databases quite frequently. But in versions of Oracle before 12C, this feature was not available and so what people often did was to use the combination of an Oracle sequence and a trigger to synthesize this behavior and in fact, if you work with Oracle for any length of time you are sure to see code similar to what I'm about ready to show you because historically this has been one of the most frequent used cases for triggers in Oracle. So how would we accomplish this? We'll go ahead and start with the definition of our sequence and trigger. And so you can see in the sequence definition here at the top of the screen, I'm actually going to start my sequence at 10 just because I already have some rows in this table and I need to make sure that my sequence is generating unique values and I want those values to be greater than what I already have in the table. So that's why I'm starting at a value of 10. Then we have the trigger definition and you see what this is doing, is it's going to fire before an insert of each row, and then in the definition, it's going to take the next value of the sequence and it's going to put that into the student ID field of the new pseudo record. So again, we have this concept going on that we're intercepting the statement before it actually executes and that's going to allow us to put the generated value from the Oracle sequence into the student ID field. So let's go ahead and create each of these. And there we go, those are created and now we'll insert a new row into our table. So here is our insert statement and you'll notice that we're not specifying a value for a student ID. Instead this value is going to get populated by the trigger using the sequence that we just defined. So let's go ahead and run this statement. And there we go, we do have one row inserted and now we can query the data back out of our table. And we see indeed, we have populated the student ID value for our new row using the trigger and the sequence. If you're in Oracle 12C you could of course just use an autogenerating identity column and if you're unfamiliar with how to do that check out my course on Oracle data types also here on Pluralsight. However, there are quite a few tables out there that use a trigger like this and so if you work with Oracle for any length of time, you're going to run into these and so it's good to be familiar with how they work.

Compound Triggers

In the triggers that we've looked at so far, they fire at only a single point in the life cycle of a DML statement. A compound trigger is a trigger that can fire at multiple points in the statement life cycle. But it's also very useful is that within a compound trigger you can share a variable state across these different firing points. So for example, if you set the value of a variable in the before each row section of a trigger, you can access that same value in the after each row section. This becomes very useful in a couple of scenarios. The first is when you want to collect a number of rows and insert them into a second table like a bulk insert operation. The second is when you're performing a bulk update operation against a table and you need to get a value at the beginning of the operation and then use that same value for a comparison on each row when the trigger fires. Since compound triggers have variables that can be shared across the firing points of the trigger this can be easily accomplished. On this slide, we see the syntax to define a compound trigger and we see that it's a little bit different than the normal triggers we've been looking at. We simply say insert, update, or delete in this case, and we don't need to specify a before or after or for each row clause. As we're going to handle all of that below. Once again, if we want the trigger to fire on multiple statement types, we can simply or together insert, update, or delete. The next important point is that we use the keywords compound trigger, and this lets Oracle know that we are indeed defining a compound trigger. Then right after the compound trigger clause, you can declare any variables that you want to be available to trigger wide. And then you can access these variables in any of the firing point sections that we will define below. You also can define in line PL sequel procedures in this section that you can access from each firing point as well. Finally, we have the definition for each of our firing points, and these are pretty logical. Before each statement, before each row, and so on. And inside of these, this is where we include the logic that will need to occur at that point in the statement life cycle. So for example, we could query some value out of our database in the before statement section, store that in a variable, and then use that value later in the before each row section. If we don't have any logic that we need to execute for one of these sections, that's okay, we can just leave out the entire section in our trigger definition. The big upside to a compound trigger though is that fact that we're defining the logic for each one of these firing points in one trigger and then we can share variables between these different firing points and that's something that just isn't possible with a normal trigger. So let's move into an example of seeing a compound trigger in action so we can understand how this works.

Demo: Compound Triggers

So here we have a compound trigger and what this trigger is going to do is archive any rows that are changing our student's table to an archive table similar to what we did before. What is different about this trigger is that instead of inserting each archive row one by one as each row in the student's table is updated, this trigger is going to save off the changed rows in an array 100 at a time and then insert them to the archive table all at once in these groups of 100. If we are performing bulk DML operations or we have a single DML statement that modifies hundreds or thousands of rows at once. This actually turns out to be more efficient because we can make use of PL sequels equals bulk collect capability to bulk insert these archive rows rather than inserting them one by one to our archive table. So let's take a look at how this trigger works. First of all, we see that we are performing this operation on updates to the student's table. Then we see our declaration syntax. What is important here is that the variables we declare in this section, we can access in any of the firing point sections below and their scope will be preserved across the life of the DML statement that caused this trigger to fire. So what this is doing is it's defining an in-memory table of the same type of the student's archive table. So just think of this as an array and what we're going to do, is every time a row changes, we'll put the change record into that array and then we can write those records to the archive table in blocks of 100. The rest of the variables here are just to support this operation, as we see we have a variable called IDX, which helps us keep track of where we are in our array, and then we have our chunk size variable which tells us that we'll be working in blocks of 100. Scrolling down a bit. We see that we have an in-line procedure for this trigger to use and this is the procedure that will actually perform the insert to the students_archive table. What is actually important is this for all syntax, which is going to signal to Oracle to use the bulk collect capability in PL sequel so those records can be inserted in bulk and not one by one. Otherwise, this is a pretty straightforward procedure, there's just an insert statement and we see down here, once we insert a block of records, we're clearing out our array and setting the index back to zero so we can reset and get ready for the next block of rows. Scrolling down again, we will see our firing point definitions. So first of all, after each row, we are taking a copy of the old values from the row and putting those into the next position in our array. And then we check to see if the array has 100 elements in it and if so, we're going to go ahead and insert those into the archive table and reset our array so we don't build up too many items. Finally, in the after statement section we call insert archive records one more time just so we can archive any remaining records that are in the array. So while this trigger is long, it really isn't doing anything too complicated. Basically we are using an array to gather up the change records and then we're inserting those into the archive table at regular intervals. And the reason that we can do this is because of the shared state that we have in the compound trigger. So let's go ahead and create this trigger and do some updates. So there we go, our trigger has been created. And now we're going to update some rows. And so what I'm going to do is I'm going to change everyone's e-mail address in this table to firstname.lastname at the fictional domain for our university and this is a somewhat contrived example, but the point is that we're going to perform a DML statement that's affecting many, many records in our table, not just affecting one record at a time. And in these cases, a compound trigger can give better performance because of the bulk inserting to the archive table. We're not going to measure that performance here, we're just going to prove that the trigger does work. So let's go ahead and run this statement. And there we go, we see that we updated four rows and now let's take a look at our archive table and I should tell you that I did clear the table out before the demonstration, so any records in there are just from the statement that we just ran. We'll move this up so we can see a little bit better here, and we see, indeed we do have the prior versions of the rows in this table. If you have a table that you need to archive records from and you're performing a lot of DML that impacts a large number of rows in the table, then a compound trigger, like this, is probably going to be your best choice. If you're always doing single row updates, then a regular trigger like what we looked at earlier is going to work just fine for you. What you do what to take away from this though, is that if you have a need to share state across different firing points in your trigger or keep state of the entire life cycle of the DML statement that caused the trigger to fire in the first place, then a compound trigger is the type of trigger that you'll want to use.

Summary

In this module, we've come up to speed on database triggers in Oracle. We started off by defining what triggers are, when you might want to use one, and what different types of triggers are available. We then dive into the syntax of triggers, including how to create a trigger, how to determine what type of statement caused the trigger to fire. How to access the old and new versions of a row in a trigger, and how to define what order of the triggers on a table will fire in. Next we worked through several examples of common triggers, so we could understand, in detail, how triggers work, and finally, we wrapped up by talking about compound triggers, which are a different type of trigger that allows you to share state across multiple firing points within the trigger. One last note for you, I have posted all of the example triggers I used in this module out on my blog. So if you're interested in playing around with those on our own or adapting them for your own purposes, then just head over to the address you see on your screen and go to the triggers tag and you'll find all of the code there.

Course author

    
David Berry
David Berry is a software engineer with over 15 years of experience developing applications in languages such as Java and C#. Throughout his career, he has worked extensively with enterprise...
Course info

LevelBeginner
Rating
(97)
My rating
Duration1h 40m
Released17 Feb 2015
Share course

